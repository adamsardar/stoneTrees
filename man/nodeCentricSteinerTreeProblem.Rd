% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nodeCentricSteinerTreeProblem-class.R
\docType{class}
\name{nodeCentricSteinerTreeProblem}
\alias{nodeCentricSteinerTreeProblem}
\title{Solve Steiner problems (MStTP or MWCS) with uniform or no edge weights.}
\format{
R6Class \code{nodeCentricSteinerTreeProblem} Construct an object representation of a Steiner tree/maximum weight connected subgraph (MWCS) problem, with methods to find solutions
}
\description{
The base stoneTrees class for solving Steiner Tree problems. Each object constructed represents a single Steiner problem
and the associated methods allow for modifications, solution generation etc. See *examples* below.
}
\details{
Input networks must be single component igraph objects with node attributes detailing forced node inclusion in solution ($isTerminal = TRUE)
and/or node costs or prizes for inclusion ($nodeScore).
}
\section{Methods}{

\describe{
   \item{\code{new(network, solverChoice = chooseSolver(), verbose = TRUE, presolveGraph = TRUE, solverTimeLimit = 300, solverTrace = as.integer(verbose))}}{ Constructor for object. Most options can be left as default, but one can set verbose (boolean) and solverTrace (integer - see ?cplexAPI::CPX_PARAM_SCRIND) as desired to prevent output.}
   \item{\code{findSingleSteinerSolution()}}{Initiate a search for a connected solution to the CURRENT constraints. For derived classes this can mean that the solution changes.}
   \item{\code{getCurrentSolutionGraph()}}{Retrieve the current solution graph (could be disconnected)}
   \item{\code{get*Constraints()}}{Extract relevant constraints }
   \item{\code{getCurrentSolutionScore()}}{Compute the objective value of the current solution.}
   \item{...}{Other methods are self explanatory and likely uninteresting to a general user}
}
}

\examples{
library(igraph)

 # Minimum Steiner tree problem

 ## Boolean flags on vertices mark out 'seeds' (nodes that *must* be included)
 unique(V(karateGraph)$isTerminal)
 V(karateGraph)[isTerminal]

 karateMStTP <- nodeCentricSteinerTreeProblem$new(karateGraph)
 karateMStTP$findSingleSteinerSolution()

 # Maximum-Weight Connected Subgraph (MWCS)

 ## Vertex attribute details node costs/prizes
 head(V(lymphomaGraph)$nodeScore)

 lymphomaMWCS <- nodeCentricSteinerTreeProblem$new(lymphomaGraph)
 lymphomaMWCS$findSingleSteinerSolution()

 # A blend of the two approaches

 ## Say there are some nodes (e.g. drug binding targets) that *must* be included, 
 
 # but otherwise node inclusion should follow node scores
 V(lymphomaGraph)$isTerminal <- FALSE
 ## Choose some random nodes to be seeds
 V(lymphomaGraph)[name \%in\% c("4","8","15","16","23","42")]$isTerminal <- TRUE

 hybridSteinProb <- nodeCentricSteinerTreeProblem$new(lymphomaGraph)
 hybridSteinProb$findSingleSteinerSolution()
}
\references{
Fischetti M, Leitner M, Ljubić I, Luipersbeck M, Monaci M, Resch M, et al. Thinning out Steiner trees: a node-based model for uniform edge costs. Math Program Comput. dimacs11.cs.princeton.edu; 2017;9: 203–229.

Beisser D, Klau GW, Dandekar T, Müller T, Dittrich MT. BioNet: An R-Package for the functional analysis of biological networks. Bioinformatics. 2010;26: 1129–1130.

\url{https://en.wikipedia.org/wiki/Steiner_tree_problem}
}
\seealso{
Other SteinerProblemSolver: 
\code{\link{nodeCentricSteinerForestProblem}},
\code{\link{subOptimalSteinerProblem}}
}
\concept{SteinerProblemSolver}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{nodeCentricSteinerTreeProblem$new()}}
\item \href{#method-isSolutionConnected}{\code{nodeCentricSteinerTreeProblem$isSolutionConnected()}}
\item \href{#method-getCurrentSolutionGraph}{\code{nodeCentricSteinerTreeProblem$getCurrentSolutionGraph()}}
\item \href{#method-getCurrentSolutionScore}{\code{nodeCentricSteinerTreeProblem$getCurrentSolutionScore()}}
\item \href{#method-getTerminals}{\code{nodeCentricSteinerTreeProblem$getTerminals()}}
\item \href{#method-findSingleSteinerSolution}{\code{nodeCentricSteinerTreeProblem$findSingleSteinerSolution()}}
\item \href{#method-getNodeDT}{\code{nodeCentricSteinerTreeProblem$getNodeDT()}}
\item \href{#method-getEdgeDT}{\code{nodeCentricSteinerTreeProblem$getEdgeDT()}}
\item \href{#method-getFixedTerminalConstraints}{\code{nodeCentricSteinerTreeProblem$getFixedTerminalConstraints()}}
\item \href{#method-getNodeDegreeConstraints}{\code{nodeCentricSteinerTreeProblem$getNodeDegreeConstraints()}}
\item \href{#method-getTwoCycleConstraints}{\code{nodeCentricSteinerTreeProblem$getTwoCycleConstraints()}}
\item \href{#method-getConnectivityConstraints}{\code{nodeCentricSteinerTreeProblem$getConnectivityConstraints()}}
\item \href{#method-clone}{\code{nodeCentricSteinerTreeProblem$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{nodeCentricSteinerTreeProblem$new(
  network,
  solverChoice = chooseSolver(),
  verbose = TRUE,
  presolveGraph = TRUE,
  solverTimeLimit = 300,
  solverTrace = as.integer(verbose)
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-isSolutionConnected"></a>}}
\if{latex}{\out{\hypertarget{method-isSolutionConnected}{}}}
\subsection{Method \code{isSolutionConnected()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{nodeCentricSteinerTreeProblem$isSolutionConnected()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getCurrentSolutionGraph"></a>}}
\if{latex}{\out{\hypertarget{method-getCurrentSolutionGraph}{}}}
\subsection{Method \code{getCurrentSolutionGraph()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{nodeCentricSteinerTreeProblem$getCurrentSolutionGraph()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getCurrentSolutionScore"></a>}}
\if{latex}{\out{\hypertarget{method-getCurrentSolutionScore}{}}}
\subsection{Method \code{getCurrentSolutionScore()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{nodeCentricSteinerTreeProblem$getCurrentSolutionScore()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getTerminals"></a>}}
\if{latex}{\out{\hypertarget{method-getTerminals}{}}}
\subsection{Method \code{getTerminals()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{nodeCentricSteinerTreeProblem$getTerminals()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-findSingleSteinerSolution"></a>}}
\if{latex}{\out{\hypertarget{method-findSingleSteinerSolution}{}}}
\subsection{Method \code{findSingleSteinerSolution()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{nodeCentricSteinerTreeProblem$findSingleSteinerSolution(maxItr = 20)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getNodeDT"></a>}}
\if{latex}{\out{\hypertarget{method-getNodeDT}{}}}
\subsection{Method \code{getNodeDT()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{nodeCentricSteinerTreeProblem$getNodeDT()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getEdgeDT"></a>}}
\if{latex}{\out{\hypertarget{method-getEdgeDT}{}}}
\subsection{Method \code{getEdgeDT()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{nodeCentricSteinerTreeProblem$getEdgeDT()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getFixedTerminalConstraints"></a>}}
\if{latex}{\out{\hypertarget{method-getFixedTerminalConstraints}{}}}
\subsection{Method \code{getFixedTerminalConstraints()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{nodeCentricSteinerTreeProblem$getFixedTerminalConstraints()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getNodeDegreeConstraints"></a>}}
\if{latex}{\out{\hypertarget{method-getNodeDegreeConstraints}{}}}
\subsection{Method \code{getNodeDegreeConstraints()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{nodeCentricSteinerTreeProblem$getNodeDegreeConstraints()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getTwoCycleConstraints"></a>}}
\if{latex}{\out{\hypertarget{method-getTwoCycleConstraints}{}}}
\subsection{Method \code{getTwoCycleConstraints()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{nodeCentricSteinerTreeProblem$getTwoCycleConstraints()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getConnectivityConstraints"></a>}}
\if{latex}{\out{\hypertarget{method-getConnectivityConstraints}{}}}
\subsection{Method \code{getConnectivityConstraints()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{nodeCentricSteinerTreeProblem$getConnectivityConstraints()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{nodeCentricSteinerTreeProblem$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
