---
title: "Untitled"
output: html_document
editor_options:
  chunk_output_type: console
---
```{r}
library(data.table)
library(dplyr)
library(igraph)
library(InteractomeServices)
library(purrr)
library(ggplot2)
library(stringr)
devtools::load_all()
```

```{r}
PtoExclude <- fread("~/Documents/InternalDiscoveryProjects/covid19/EmpiricalHostVirusPPI/Resources/proteins_to_exclude.tsv")

```

```{r}
searchOptions <- samplingStrategyOptions(includedTaxonomies= 9606, filteredAccession = PtoExclude$Accession)

interactome <- generateWorkbenchFilteredNetwork("ETX Interactome v5.2.0", searchOptions)

undirected <- as.undirected(interactome, mode = "collapse")

simpleUndirected <- simplify(undirected)

simpleUndirectedBiggestComponent <- decompose(simpleUndirected) %>% .[order(map_int(., vcount), decreasing = TRUE)] %>%.[[1]]

interactome <- simpleUndirectedBiggestComponent

vcount(interactome)
ecount(interactome)

vcount(lymphomaGraph)
ecount(lymphomaGraph)
```


```{r}

#seeds <- fread("~/Documents/Workflows/network_construction/data/Table2Head50.txt")

seedName <- list.files("~/Documents/InternalDiscoveryProjects/covid19/EmpiricalHostVirusPPI/covid19Translatome/Resources/Seeds", pattern = ".txt")

seedSetlist <- map(seedName, ~{ fread(paste0("~/Documents/InternalDiscoveryProjects/covid19/EmpiricalHostVirusPPI/covid19Translatome/Resources/Seeds/", .x)  ) })


names(seedSetlist) <- str_remove(seedName, ".txt")

seedSetlist <- map(seedSetlist, ~{  .x[Accession %in% V(interactome)$name] })

#print("Number of proteins in each seed sets")
#map(seedSetlist, ~{.x[, Accession] %>% unique %>% length })

#seedName <- list.files("~/Documents/PartnerDiscoveryProjects/novonordiskgains", pattern = ".txt")

#seedSetlist <- map(seedName[1:9], ~{ fread(paste0("~/Documents/PartnerDiscoveryProjects/novonordiskgains/", .x)  ) })


#names(seedSetlist) <- str_remove(seedName[1:9], ".txt")


#seedSetlist <- map(seedSetlist, ~{ setnames(.x, "ProteinAccession", "Accession")
#                    .x } )


```

```{r}



MStTBenchDT <-map2(seedSetlist, names(seedSetlist), function(seeds,name){


  #seeds <- seedSetlist$TranslatomeCluster3
  
  V(interactome)$isTerminal <- V(interactome)$name %in% seeds$Accession


  Results <- map(stoneTrees_solvers[1:3], ~{

print(.x)

  # Note, The two process are not solving the exact same problem. Stochastic algorithms are a pain

time <- system.time( SteinForSolverX <- subOptimalSteinerProblem$new(interactome,
                                                                               solverChoice = .x,
                                                                               verbose = TRUE,
                                                                               solverTrace = 0)$identifyMultipleSteinerSolutions(maxItr = 5) )


NconnectivityConstraintsCalls <- SteinForSolverX$getNconnectivityConstraintsCalls()


SolutionPool <- SteinForSolverX$getSolutionPoolGraphs(collapseSols = FALSE)


save(SolutionPool, file = paste0("./results/etxInteractome_MStTSolver_",name, "_",.x,".RData"))



    Sizes <- map_int(SolutionPool, vcount)

  return(data.table(solver = paste(.x),
                    seedSet = paste(name),
                    time = time["elapsed"],
                    vcount = vcount(SteinForSolverX$getSolutionPoolGraphs()),
                    modulesVcount = list(Sizes),
                    Niteration = length(Sizes),
                    NconnectivityConstraintsCalls = list(NconnectivityConstraintsCalls) ))



}) %>% rbindlist()


return(Results)  

  })  %>% rbindlist()


fwrite(MStTBenchDT, paste0("./results/etxInteractome_MStTSolver.tsv"))

MStTBenchDT
```



```{r}



SFBenchDT <-map2(seedSetlist, names(seedSetlist), function(seeds,name){

  
  #seeds <- seedSetlist$TranslatomeCluster4

  V(interactome)$isTerminal <- V(interactome)$name %in% seeds$Accession


  Results <- map(stoneTrees_solvers[1:3], ~{

print(.x)

  # Note, The two process are not solving the exact same problem. Stochastic algorithms are a pain

time <- system.time( SteinForSolverX <- nodeCentricSteinerForestProblem$new(interactome,
                                                                               solverChoice = .x,
                                                                               verbose = TRUE,
                                                                               solverTrace = 0)$sampleMultipleBootstrapSteinerSolutions(nBootstraps = 3, maxItr = 3) )


NconnectivityConstraintsCalls <- SteinForSolverX$getNconnectivityConstraintsCallsPool()
#NconnectivityConstraintsCalls

SolutionPool <- SteinForSolverX$getBootstrapSolutionPoolGraphs(collapseSols = FALSE)


#length(NconnectivityConstraintsCalls) == length(SolutionPool[-length(SolutionPool)])

save(SolutionPool, file = paste0("./results/etxInteractome_SFSolver_",name, "_",.x,".RData"))



    Sizes <- map_int(SolutionPool, vcount)

  return(data.table(solver = paste(.x),
                    seedSet = paste(name),
                    time = time["elapsed"],
                    vcount = vcount(SteinForSolverX$getBootstrapSolutionPoolGraphs()),
                    modulesVcount = list(Sizes[-length(Sizes)]),
                    Niteration = length(Sizes[-length(Sizes)]),
                     NconnectivityConstraintsCalls = list(NconnectivityConstraintsCalls)))



}) %>% rbindlist()


return(Results)  

  })  %>% rbindlist()


fwrite(SFBenchDT, paste0("./results/etxInteractome_SFSolver.tsv"))

SFBenchDT
```

```{r}
DT <- fread(file = "./results/etxInteractome_MStTSolver.tsv")%>% 
  .[,`:=`(samplingMethod = "MStT", 
          modulesVcount =  strsplit(modulesVcount, "\\|"),
          NconnectivityConstraintsCalls =  strsplit(NconnectivityConstraintsCalls, "\\|"))]

```


```{r}
ETXinteractomeBenchDT <- rbind(fread(file = "./results/etxInteractome_SFSolver.tsv") %>% .[,`:=`(samplingMethod = "SF", 
                                                                  modulesVcount =  strsplit(modulesVcount, "\\|"),
                                                                  NconnectivityConstraintsCalls =  strsplit(NconnectivityConstraintsCalls, "\\|"))],
fread(file = "./results/etxInteractome_MStTSolver.tsv") %>% .[,`:=`(samplingMethod = "MStT", 
                                                                  modulesVcount =  strsplit(modulesVcount, "\\|"),
                                                                  NconnectivityConstraintsCalls =  strsplit(NconnectivityConstraintsCalls, "\\|"))])


```

```{r}

ETXinteractomeBenchDT[, .(`TotalTime(hours)` = sum(time)/60/60), by = .(solver, samplingMethod)] 

ETXinteractomeBenchDT[, .(TotalTime = sum(time)/60/60), by = .(solver)][,TotalTime] %>% sum

ETXinteractomeBenchDT[, .(AvSise = mean(vcount)), by = .(solver, seedSet, samplingMethod)] 


```

```{r}
p1 <- ggplot(ETXinteractomeBenchDT, aes(x = solver, y = time/60)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.1, height = 0, aes(color =seedSet)) +
  facet_wrap(~samplingMethod)+
  theme_minimal(base_size = 20) +
  theme(legend.position = "none")+
  labs(y = "Time (min)",
       title = "Time taken to solve Steiner problem")

p2 <- ggplot(ETXinteractomeBenchDT, aes(x = solver, y = time/60)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.1, height = 0, aes(color =seedSet)) +
  facet_wrap(~samplingMethod)+
  theme_minimal(base_size = 20) +
  theme(legend.position = "none")+
  scale_y_log10()+
  labs(y = "Time (logScale)",
       title = "Time taken to solve Steiner problem")


#
p3 <- ggplot(ETXinteractomeBenchDT, aes(x = solver, y = vcount))+
  #geom_boxplot(outlier.shape = NA) +
  facet_wrap(~samplingMethod)+
  geom_jitter(width = 0.1, height = 0, aes(color =seedSet)) +
  theme_minimal(base_size = 20) +
  #scale_color_hue()+
  theme(legend.position = "none")+
  labs( y = "Aggregated module size",
        title = "Size of the solutions")


p4 <- ETXinteractomeBenchDT[,.(modulesVcount = unlist(modulesVcount)), by = .(solver, time, vcount, Niteration, seedSet, samplingMethod)] %>%

  ggplot(., aes(x = solver, y = as.numeric(modulesVcount))) +
  facet_wrap(~seedSet + samplingMethod, nrow = 5, scales = "free")+
  geom_jitter(width = 0.1, height = 0, aes(color = solver)) +
  geom_boxplot(outlier.shape = NA) +
  theme_minimal(base_size = 20) +
  theme(legend.position = "none")+
  labs(y = "vCount of all modules",
       title = "Individual tree solutions")+
  scale_y_continuous(breaks = seq(0,135,1))




p5 <- ggplot(ETXinteractomeBenchDT, aes(x = solver, y = Niteration)) +
  geom_boxplot(outlier.shape = NA) +
  facet_wrap(~samplingMethod)+
  geom_jitter(width = 0.1, height = 0, aes(color =seedSet)) +
  theme_minimal(base_size = 20) +
  theme(legend.position = "right")+
  labs(y = "Number of solutions",
       title = "Size of solution pool")+
  scale_y_continuous(breaks = seq(0,13,3))


p6 <- ETXinteractomeBenchDT[,.(NconnectivityConstraintsCalls = unlist(NconnectivityConstraintsCalls)), by = .(solver, time, vcount, Niteration, seedSet, samplingMethod)] %>%

  ggplot(., aes(x = solver, y = as.numeric(NconnectivityConstraintsCalls))) +
  facet_wrap(~seedSet + samplingMethod, nrow = 5, scales = "free")+
  geom_jitter(width = 0.1, height = 0, aes(color = solver)) +
  geom_boxplot(outlier.shape = NA) +
  theme_minimal(base_size = 20) +
  #scale_y_log10()+
  theme(legend.position = "none")+
  labs(y = "number of 'adding connectivity constraints' cycles",
       title = "Individual tree solutions")+
  scale_y_continuous(breaks = seq(0,20,1))



plot1 <- egg::ggarrange(p2,p3, p5, 
                       
                       #heights = c(0.15, 0.15, 0.7),
                       
                       ncol = 2,
                       
                       top =  paste(
  
  "MStT : collecting up to 5 degenerate solutions \n SF : 3 bootstraps collecting up to 3 degenerate solutions"))


plot2 <- egg::ggarrange(p4, p6, 
                       
                       #heights = c(0.15, 0.15, 0.7),
                       
                       ncol = 2,
                       
                       top =  paste(
  
  "MStT : collecting up to 5 degenerate solutions \n SF : 3 bootstraps collecting up to 3 degenerate solutions"))


#ggpubr::ggarrange(p1,p2,p3,p5)

ggsave(plot = plot1, filename = "./results/etxInteractomeSolverTest1.png", width = 16, height = 15)

ggsave(plot = plot2, filename = "./results/etxInteractomeSolverTest2.png", width = 18, height = 30)
```








```{r}
T2DETXinteractomeBenchDT <- rbind(fread(file = "./results/etxInteractome_T2D_SFSolver.tsv") %>% .[,`:=`(samplingMethod = "SF", 
                                                                  modulesVcount =  strsplit(modulesVcount, "\\|"))],
fread(file = "./results/etxInteractome_T2D_MStTSolver.tsv") %>% .[,`:=`(samplingMethod = "MStT", 
                                                                  modulesVcount =  strsplit(modulesVcount, "\\|"))])


```

```{r}

T2DETXinteractomeBenchDT[, .(`TotalTime(hours)` = sum(time)/60/60), by = .(solver, samplingMethod)] 

T2DETXinteractomeBenchDT[, .(TotalTime = sum(time)/60/60), by = .(solver)][,TotalTime] %>% sum

T2DETXinteractomeBenchDT[, .(AvSise = mean(vcount)), by = .(solver, seedSet, samplingMethod)] 


```

```{r}
p1 <- ggplot(T2DETXinteractomeBenchDT, aes(x = solver, y = time/60)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.1, height = 0, aes(color =seedSet)) +
  facet_wrap(~samplingMethod)+
  theme_minimal(base_size = 20) +
  theme(legend.position = "none")+
  labs(y = "Time (min)",
       title = "Time taken to solve Steiner problem")

p2 <- ggplot(T2DETXinteractomeBenchDT, aes(x = solver, y = time/60)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.1, height = 0, aes(color =seedSet)) +
  facet_wrap(~samplingMethod)+
  theme_minimal(base_size = 20) +
  theme(legend.position = "none")+
  scale_y_log10()+
  labs(y = "Time (logScale)",
       title = "Time taken to solve Steiner problem")


#
p3 <- ggplot(T2DETXinteractomeBenchDT, aes(x = solver, y = vcount))+
  #geom_boxplot(outlier.shape = NA) +
  facet_wrap(~samplingMethod)+
  geom_jitter(width = 0.1, height = 0, aes(color =seedSet)) +
  theme_minimal(base_size = 20) +
  #scale_color_hue()+
  theme(legend.position = "none")+
  labs( y = "Aggregated module size",
        title = "Size of the solutions")


p4 <- T2DETXinteractomeBenchDT[,.(modulesVcount = unlist(modulesVcount)), by = .(solver, time, vcount, Niteration, seedSet, samplingMethod)] %>%

  ggplot(., aes(x = solver, y = as.numeric(modulesVcount))) +
  facet_wrap(~seedSet + samplingMethod, nrow = 5)+
  geom_jitter(width = 0.1, aes(color = solver)) +
  geom_boxplot(outlier.shape = NA) +
  theme_minimal(base_size = 20) +
  theme(legend.position = "none")+
  labs(y = "vCount of all module",
       title = "Individual tree solutions")




p5 <- ggplot(T2DETXinteractomeBenchDT, aes(x = solver, y = Niteration)) +
  geom_boxplot(outlier.shape = NA) +
  facet_wrap(~samplingMethod)+
  geom_jitter(width = 0.1, aes(color =seedSet)) +
  theme_minimal(base_size = 20) +
  theme(legend.position = "none")+
  labs(y = "Number of solutions",
       title = "Size of solution pool")


plot <- egg::ggarrange(p1,p2,p3,p5, p4, 
                       
                       heights = c(0.15, 0.15, 0.7),
                       
                       ncol = 2,
                       
                       top =  paste(
  
  "MStT : collecting up to 5 degenerate solutions \n SF : 1 bootstrap collection up to 2 degenerate solutions"))


#ggpubr::ggarrange(p1,p2,p3,p5)


ggsave(plot = plot, filename = "./results/T2DETXinteractomeSolverTest.png", width = 16, height = 30)
```




